import { useEffect, useState } from "react";
import { FiDownload } from "react-icons/fi";
import ExcelJS from "exceljs";
import styles from "./ExcelExport.module.css";
import useConfigurationsEmv, {
  ConfigurationsEmv,
} from "../../api/hooks/useConfigurationsEmv";
import { extractErrorMessage } from "../../utils/extractErrorMessage";
import AlertModal from "../common/AlertModal/AlertModal";
interface ExcelExportProps<T> {
  data: T[];
  columns: {
    id: string;
    label: string;
  }[];
  visibleColumns: string[];
  fileName?: string;
  disabled?: boolean;
  metadata?: {
    title?: string;
    totalRecords?: number;
    page?: number;
    totalPages?: number;
    filters?: Record<string, any>;
  };
  formatters?: {
    [key: string]: (value: any) => string;
  };
  cellStylers?: {
    [key: string]: (cell: any, row: T, rowIndex: number) => void;
  };
}
const ExcelExport = <T extends Record<string, any>>({
  data,
  columns,
  visibleColumns,
  fileName = "export",
  disabled = false,
  metadata = {},
  formatters = {},
  cellStylers = {},
}: ExcelExportProps<T>) => {
  const [exporting, setExporting] = useState(false);
  const { getConfigurations } = useConfigurationsEmv();
  const [config, setConfig] = useState<ConfigurationsEmv | null>(null);
  const [alertModal, setAlertModal] = useState<{
    title: string;
    message: string;
    error: boolean;
  } | null>(null);
  const [loading, setLoading] = useState(true);
  useEffect(() => {
    const fetchData = async () => {
      try {
        const data = await getConfigurations();
        setConfig(data);
      } catch (error) {
        extractErrorMessage(error, "Failed to load configurations");
      } finally {
        setLoading(false);
      }
    };
    void fetchData();
  }, []);
  const formatCellValue = (value: any, columnId: string): string => {
    if (value === undefined || value === null) {
      return "-";
    }
    if (formatters[columnId]) {
      return formatters[columnId](value);
    }
    if (typeof value === "object") {
      if ("amount" in value && "currency" in value) {
        return `${value.amount} ${value.currency || ""}`;
      }
      return JSON.stringify(value);
    }
    return String(value);
  };

  const exportToExcel = async () => {
    if (data.length === 0) {
      setAlertModal({
        title: "Error Exporting Excel",
        message: "No data available to export.",
        error: true,
      });
      return;
    }
    setExporting(true);
    try {
      const workbook = new ExcelJS.Workbook();
      workbook.created = new Date();
      const worksheet = workbook.addWorksheet("Data");
      const exportColumns = visibleColumns.filter(
        (col) => !["actions", "request", "response"].includes(col)
      );
      const headers = exportColumns.map((col) => {
        const column = columns.find((c) => c.id === col);
        return column ? column.label : col;
      });
      const title = metadata.title || "Data Export";
      const titleRow = worksheet.addRow([title]);
      titleRow.font = { size: 16, bold: true };
      titleRow.alignment = { horizontal: "center" };
      worksheet.mergeCells(
        "A1:" + String.fromCharCode(65 + headers.length - 1) + "1"
      );
      let currentRow = 3;
      worksheet.getCell(
        `A${currentRow}`
      ).value = `Export Date: ${new Date().toLocaleString()}`;
      currentRow++;
      const totalRecords = metadata.totalRecords || data.length;
      worksheet.getCell(
        `A${currentRow}`
      ).value = `Total Records: ${totalRecords}`;
      currentRow++;
      worksheet.getCell(`A${currentRow}`).value = `Generated By: ${
        config?.fiName || "Unknown User"
      }`;
      currentRow++;
      if (metadata.page) {
        worksheet.getCell(`A${currentRow}`).value = `Page: ${metadata.page}`;
        currentRow++;
      }
      if (metadata.filters && Object.keys(metadata.filters).length > 0) {
        const filters = Object.entries(metadata.filters)
          .filter(
            ([_, value]) =>
              value !== undefined && value !== null && value !== ""
          )
          .map(([key, value]) => `${key}: ${value}`)
          .join(", ");
        if (filters) {
          worksheet.getCell(`A${currentRow}`).value = `Filters: ${filters}`;
          currentRow++;
        }
      }
      currentRow++;
      const headerRow = worksheet.getRow(currentRow);
      headers.forEach((header, index) => {
        const cell = headerRow.getCell(index + 1);
        cell.value = header;
        cell.font = {
          bold: true,
          color: { argb: "FFFFFFFF" },
        };
        cell.fill = {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "FF4F46E5" },
        };
        cell.alignment = {
          horizontal: "center",
          vertical: "middle",
        };
        cell.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" },
        };
      });
      headerRow.height = 25;
      data.forEach((item, index) => {
        const rowData = exportColumns.map((colId) => {
          const value = item[colId];
          return formatCellValue(value, colId);
        });
        const row = worksheet.addRow(rowData);
        row.eachCell((cell) => {
          cell.border = {
            top: { style: "thin" },
            left: { style: "thin" },
            bottom: { style: "thin" },
            right: { style: "thin" },
          };
        });
        exportColumns.forEach((colId, colIndex) => {
          if (cellStylers[colId]) {
            const cell = row.getCell(colIndex + 1);
            cellStylers[colId](cell, item, index);
          }
        });
        if (index % 2 === 0) {
          row.eachCell((cell) => {
            cell.fill = {
              type: "pattern",
              pattern: "solid",
              fgColor: { argb: "FFF8FAFC" },
            };
          });
        }
      });
      worksheet.columns = headers.map((header, index) => {
        const maxLength = Math.max(
          header.length,
          ...data.map((item) => {
            const colId = exportColumns[index];
            const value = item[colId];
            return formatCellValue(value, colId).length;
          })
        );
        return { width: Math.min(Math.max(maxLength + 2, 10), 50) };
      });
      const buffer = await workbook.xlsx.writeBuffer();
      const blob = new Blob([buffer], {
        type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement("a");
      const today = new Date();
      const dateStr = today.toISOString().split("T")[0];
      const timeStr =
        today.getHours().toString().padStart(2, "0") +
        today.getMinutes().toString().padStart(2, "0");
      const finalFileName = `${fileName}_${dateStr}_${timeStr}.xlsx`;
      link.href = url;
      link.download = finalFileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      setAlertModal({
        title: "Error Exporting Excel",
        message: extractErrorMessage(
          error,
          "An error occurred during Excel export."
        ),
        error: true,
      });
    } finally {
      setExporting(false);
    }
  };
  return (
    <>
      <button
        onClick={exportToExcel}
        disabled={disabled || exporting || data.length === 0}
        className={`${styles.exportButton} ${
          exporting ? styles.exporting : ""
        }`}
        title="Export to Excel"
      >
        <FiDownload />
        {exporting ? "Exporting..." : "Export Excel"}
      </button>

      {alertModal && (
        <AlertModal
          title={alertModal.title}
          message={alertModal.message}
          error={alertModal.error}
          onConfirm={() => setAlertModal(null)}
          onClose={() => setAlertModal(null)}
        />
      )}
    </>
  );
};

export default ExcelExport;
