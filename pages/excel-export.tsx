import { useEffect, useState } from "react";
import { FiDownload } from "react-icons/fi";
import ExcelJS from "exceljs";
import styles from "../styles/ExcelExport.module.css";
import useConfigurationsEmv, {
  ConfigurationsEmv,
} from "../api/hooks/useConfigurationsEmv";
import { AxiosError } from "axios";

interface ExcelExportProps<T> {
  data: T[];
  columns: {
    id: string;
    label: string;
  }[];
  visibleColumns: string[];
  fileName?: string;
  disabled?: boolean;
  metadata?: {
    title?: string;
    totalRecords?: number;
    page?: number;
    totalPages?: number;
    filters?: Record<string, any>;
  };

  formatters?: {
    [key: string]: (value: any) => string;
  };

  cellStylers?: {
    [key: string]: (cell: any, row: T, rowIndex: number) => void;
  };
}

const ExcelExport = <T extends Record<string, any>>({
  data,
  columns,
  visibleColumns,
  fileName = "export",
  disabled = false,
  metadata = {},
  formatters = {},
  cellStylers = {},
}: ExcelExportProps<T>) => {
  const [exporting, setExporting] = useState(false);
  const { getConfigurations } = useConfigurationsEmv();
  const [config, setConfig] = useState<ConfigurationsEmv | null>(null);
  const [loading, setLoading] = useState(true);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  useEffect(() => {
    const fetchData = async () => {
      try {
        const data = await getConfigurations();
        setConfig(data);
      } catch (error) {
        setErrorMessage(
          handleErrorMessage(error, "Failed to load configurations")
        );
      } finally {
        setLoading(false);
      }
    };

    void fetchData();
  }, []);
  const handleErrorMessage = (
    error: unknown,
    defaultMessage: string
  ): string => {
    if (typeof error === "string") return error;
    if (error instanceof AxiosError)
      return error.response?.data?.message || error.message || defaultMessage;
    if (error instanceof Error) return error.message;
    return defaultMessage;
  };
  const formatCellValue = (value: any, columnId: string): string => {
    if (value === undefined || value === null) {
      return "-";
    }

    if (formatters[columnId]) {
      return formatters[columnId](value);
    }

    if (typeof value === "object") {
      if ("amount" in value && "currency" in value) {
        return `${value.amount} ${value.currency || ""}`;
      }
      return JSON.stringify(value);
    }

    return String(value);
  };

  const exportToExcel = async () => {
    if (data.length === 0) {
      alert("No data to export");
      return;
    }

    setExporting(true);

    try {
      const workbook = new ExcelJS.Workbook();
      workbook.created = new Date();

      const worksheet = workbook.addWorksheet("Data");

      const exportColumns = visibleColumns.filter(
        (col) => !["actions", "request", "response"].includes(col)
      );

      const headers = exportColumns.map((col) => {
        const column = columns.find((c) => c.id === col);
        return column ? column.label : col;
      });

      const title = metadata.title || "Data Export";
      const titleRow = worksheet.addRow([title]);
      titleRow.font = { size: 16, bold: true };
      titleRow.alignment = { horizontal: "center" };
      worksheet.mergeCells(
        "A1:" + String.fromCharCode(65 + headers.length - 1) + "1"
      );

      let currentRow = 3;

      worksheet.getCell(
        `A${currentRow}`
      ).value = `Export Date: ${new Date().toLocaleString()}`;
      currentRow++;

      const totalRecords = metadata.totalRecords || data.length;
      worksheet.getCell(
        `A${currentRow}`
      ).value = `Total Records: ${totalRecords}`;
      currentRow++;
      worksheet.getCell(`A${currentRow}`).value = `Generated By: ${
        config?.fiName || "Unknown User"
      }`;
      currentRow++;

      if (metadata.page) {
        worksheet.getCell(`A${currentRow}`).value = `Page: ${metadata.page}`;
        currentRow++;
      }

      if (metadata.filters && Object.keys(metadata.filters).length > 0) {
        const filters = Object.entries(metadata.filters)
          .filter(
            ([_, value]) =>
              value !== undefined && value !== null && value !== ""
          )
          .map(([key, value]) => `${key}: ${value}`)
          .join(", ");

        if (filters) {
          worksheet.getCell(`A${currentRow}`).value = `Filters: ${filters}`;
          currentRow++;
        }
      }

      currentRow++;

      const headerRow = worksheet.getRow(currentRow);

      headers.forEach((header, index) => {
        const cell = headerRow.getCell(index + 1);
        cell.value = header;
        cell.font = {
          bold: true,
          color: { argb: "FFFFFFFF" },
        };
        cell.fill = {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "FF4F46E5" },
        };
        cell.alignment = {
          horizontal: "center",
          vertical: "middle",
        };
        cell.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" },
        };
      });

      headerRow.height = 25;

      data.forEach((item, index) => {
        const rowData = exportColumns.map((colId) => {
          const value = item[colId];
          return formatCellValue(value, colId);
        });

        const row = worksheet.addRow(rowData);

        row.eachCell((cell) => {
          cell.border = {
            top: { style: "thin" },
            left: { style: "thin" },
            bottom: { style: "thin" },
            right: { style: "thin" },
          };
        });

        exportColumns.forEach((colId, colIndex) => {
          if (cellStylers[colId]) {
            const cell = row.getCell(colIndex + 1);
            cellStylers[colId](cell, item, index);
          }
        });

        if (index % 2 === 0) {
          row.eachCell((cell) => {
            cell.fill = {
              type: "pattern",
              pattern: "solid",
              fgColor: { argb: "FFF8FAFC" },
            };
          });
        }
      });

      worksheet.columns = headers.map((header, index) => {
        const maxLength = Math.max(
          header.length,
          ...data.map((item) => {
            const colId = exportColumns[index];
            const value = item[colId];
            return formatCellValue(value, colId).length;
          })
        );
        return { width: Math.min(Math.max(maxLength + 2, 10), 50) };
      });

      const buffer = await workbook.xlsx.writeBuffer();
      const blob = new Blob([buffer], {
        type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement("a");

      const today = new Date();
      const dateStr = today.toISOString().split("T")[0];
      const timeStr =
        today.getHours().toString().padStart(2, "0") +
        today.getMinutes().toString().padStart(2, "0");
      const finalFileName = `${fileName}_${dateStr}_${timeStr}.xlsx`;

      link.href = url;
      link.download = finalFileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error("Export error:", error);
      alert("Failed to export. Please try again.");
    } finally {
      setExporting(false);
    }
  };

  return (
    <button
      onClick={exportToExcel}
      disabled={disabled || exporting || data.length === 0}
      className={`${styles.exportButton} ${exporting ? styles.exporting : ""}`}
      title="Export to Excel"
    >
      <FiDownload />
      {exporting ? "Exporting..." : "Export Excel"}
    </button>
  );
};

export default ExcelExport;
